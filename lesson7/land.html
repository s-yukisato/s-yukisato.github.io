<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <title>OrbitControls</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/99/three.min.js"></script>
    <script src="https://s-yukisato.github.io/lesson4/OrbitControls.js"></script>
    <script>
        window.addEventListener('load', init);

        function init() {

            // サイズを指定
            const width = 960;
            const height = 540;

            // レンダラーを作成
            const renderer = new THREE.WebGLRenderer({
                canvas: document.querySelector('#myCanvas'),
            });
            renderer.setSize(width, height);
            // renderer.setClearColor(0xffffff);

            // シーンを作成
            const scene = new THREE.Scene();

            // カメラを作成
            const camera = new THREE.PerspectiveCamera(60, width / height);
            // カメラの初期座標を設定
            camera.position.set(0, 200, 1000);

            // カメラコントローラーを作成
            const controls = new THREE.OrbitControls(camera, document.body);

            // helper
            const gridHelper = new THREE.GridHelper(200, 50); // size, step
            scene.add(gridHelper);

            const axisHelper = new THREE.AxisHelper(200, 50);
            scene.add(axisHelper);

            // テクスチャー読み込み
            var textureLoader = new THREE.TextureLoader();
            // 地面用
            let texture = textureLoader.load("https://s-yukisato.github.io/img/ground.jpg")
            let mat = new THREE.MeshPhongMaterial();
            mat.map = texture;
            // bump
            let bump = textureLoader.load('https://s-yukisato.github.io/img/ground-bump.jpg');
            mat.bumpMap = bump;
            mat.bumpScale = 0.3;

            // 地面用2
            let texture1 = textureLoader.load("https://s-yukisato.github.io/img/tone.jpg")
            let mat1 = new THREE.MeshPhongMaterial();
            mat1.map = texture1;
            // bump
            let bump1 = textureLoader.load('https://s-yukisato.github.io/img/tone-bump.jpg');
            mat1.bumpMap = bump1;
            mat1.bumpScale = 0.3;

            let texture2 = textureLoader.load("https://s-yukisato.github.io/img/brick.jpg")
            let mat2 = new THREE.MeshPhongMaterial();
            mat2.map = texture2;
            // bump
            let bump2 = textureLoader.load('https://s-yukisato.github.io/img/brick-bump.jpg');
            mat2.bumpMap = bump2;
            mat2.bumpScale = 0.3;

            // 階段用
            let texture_stairs = textureLoader.load("https://s-yukisato.github.io/img/stone.jpg")
            let mat_s = new THREE.MeshPhongMaterial();
            mat_s.map = texture_stairs;
            // bunp
            let bump_stairs = textureLoader.load('https://s-yukisato.github.io/img/stone-bump.jpg');
            mat_s.bumpMap = bump_stairs;
            mat_s.bumpScale = 0.3;

            let texture_tobira = textureLoader.load("https://s-yukisato.github.io/img/tobira.jpg")
            let mat_t = new THREE.MeshPhongMaterial();
            mat_t.map = texture_tobira;

            var texture_wood = textureLoader.load('https://s-yukisato.github.io/img/wood.jpg');
            var mat_w = new THREE.MeshPhongMaterial();
            mat_w.map = texture_wood;

            // normal
            let normal_w = textureLoader.load('https://s-yukisato.github.io/img/wood-nor.jpg');
            mat_w.normalMap = normal_w;
            mat_w.normalScale = new THREE.Vector2(1, -1)


            // 床
            scene.add(createFloor(mat1, 400, 150, -900))
            scene.add(createFloor(mat1, 400, 150, -500))

            scene.add(createFloor(mat1, 0, 150, -900))
            scene.add(createFloor(mat1, 0, 150, -500))
            scene.add(createFloor(mat1, 0, 150, -100))
            scene.add(createFloor(mat, 0, 0, 400))
            scene.add(createFloor(mat, 0, 0, 800))
            scene.add(createFloor(mat, 0, 0, 1200))


            // 正面壁
            let front = createWall(mat_t, 0, 0, 200, 300)
            scene.add(front)
            scene.add(createWall(mat2, 0, 0, 350, -800))
            scene.add(createWall(mat2, 0, 400, 350, -800))
            // 左壁
            scene.add(createWall(mat2, 0.5, -200, 350, -800))
            scene.add(createWall(mat2, 0.5, -200, 350, -400))

            scene.add(createWall(mat2, 0.5, -200, 200, 0))
            scene.add(createWall(mat_w, 0.5, -200, 200, 400))
            scene.add(createWall(mat_w, 0.5, -200, 200, 800))
            // 右回転
            let wall = createWall(mat2, -0.5, 200, 350, -800)
            scene.add(wall)
            scene.add(createWall(mat2, -0.5, 200, 350, -400))

            scene.add(createWall(mat2, -0.5, 200, 200, 0))
            scene.add(createWall(mat_w, -0.5, 200, 200, 400))
            scene.add(createWall(mat_w, -0.5, 200, 200, 800))


            // 宝箱をスプライトで作成
            var texture0 = textureLoader.load("https://s-yukisato.github.io/img/silver_treasure_illust_1995.png");
            const material0 = new THREE.SpriteMaterial({ map: texture0, });

            const sprite = new THREE.Sprite(material0);
            sprite.position.x = 300;
            sprite.position.y = 200;
            sprite.position.z = -700;
            sprite.scale.set(100, 100, 100);
            scene.add(sprite);

            let texture_ = textureLoader.load("https://s-yukisato.github.io/img/stone.jpg")
            let mat_ = new THREE.MeshPhongMaterial();
            mat_.map = texture_;

            let radiusTop = 250; //上面の半径です。0にすると円錐になります。
            let radiusBottom = 250; //底面の半径です。
            let objHeight = 50; //高さです。
            let radiusSegments = 0; //円周の分割数です。
            let heightSegments = 0; //高さの分割数です。
            let openEnded = true; //true：フタをしない,false：フタをする

            // const geometry_ = new THREE.CylinderGeometry(radiusTop, radiusBottom, objHeight, radiusSegments, heightSegments, openEnded)
            // const cylinder = new THREE.Mesh(geometry_, mat_);
            // scene.add(cylinder);

            var texture_block = textureLoader.load('https://s-yukisato.github.io/img/block.jpg');
            var mat_b = new THREE.MeshPhongMaterial();
            mat_b.map = texture_block;

            // normal
            let normal = textureLoader.load('https://s-yukisato.github.io/img/block-normal.jpg');
            mat_b.normalMap = normal;
            mat_b.normalScale = new THREE.Vector2(1, -1)

            // 球を作成(原点に作成)
            var geometry = new THREE.SphereGeometry(200, 32, 32);
            var ball = new THREE.Mesh(geometry, mat_b);
            ball.position.set(0, 350, -1000)
            scene.add(ball);


            // // 箱を作成(原点に作成)
            var geometry = new THREE.BoxGeometry(50, 50, 50);

            for (let z = 125; z <= 225; z += 50) {
                let y = 0;
                if (z == 125) y = 125
                else if (z == 175) y = 75
                else if (z == 225) y = 25
                for (let x = -175; x <= 175; x += 50) {
                    var box = new THREE.Mesh(geometry, mat_s)
                    box.position.x = x
                    box.position.y = y
                    box.position.z = z
                    scene.add(box)
                }
            }

            // new THREE.PointLight(色, 光の強さ, 距離, 光の減衰率)
            let pointLight = new THREE.PointLight(0x00FF00, 2, 50, 1.0);
            pointLight.position.set(0, 200, -700)
            scene.add(pointLight);

            light(100, 100, 100)
            light(-100, 100, 100)
            light(100, -100, -100)
            light(-100, -100, -100)

            function light(x, y, z) {
                // 平行光源
                var directionalLight = new THREE.DirectionalLight(0xffffff);
                directionalLight.position.set(x, y, z);
                // シーンに追加
                scene.add(directionalLight);
            }

            // const bgTexture = textureLoader.load("https://s-yukisato.github.io/img/sky_00165.jpg")
            // scene.background = bgTexture


            // 初回実行
            var update = function () {
                requestAnimationFrame(update);

                if (ball.position.z < 100) {
                    ball.rotation.x += 0.02
                    ball.position.z += 3
                } else if (ball.position.z < 300) {
                    ball.rotation.x += 0.03
                    ball.position.z += 3
                    ball.position.y -= 2
                } else {
                    ball.rotation.x += 0.05
                    ball.position.z += 5
                }

                if (camera.rotation.y < -1.15) {
                    wall.position.z += 3
                    wall.opacity -= 0.1
                }
                else if (camera.position.z < -600) {
                    camera.position.x += 0.1
                    camera.rotation.y -= 0.005
                    camera.rotation.x += 0.001
                } else if (front.position.x > 400) {
                    if (camera.position.y < 400) {
                        camera.rotation.x -= 0.005
                        camera.position.y += 2
                        camera.position.z -= 2
                    } else {
                        camera.position.z -= 3
                        camera.rotation.x += 0.001
                    }
                }
                else if (camera.position.z < 600) {
                    if (camera.rotation.x > 0.03) {
                        front.position.x += 3
                        front.rotation.y -= 0.01
                    } else {
                        camera.rotation.x += 0.005
                    }
                } else camera.position.z -= 3

                renderer.render(scene, camera);
            };
            update()

            tick();
            // 毎フレーム時に実行されるループイベントです
            function tick() {
                // レンダリング
                renderer.render(scene, camera);
                requestAnimationFrame(tick);
            }
        }

        function createPlane(mat, width = 400, height = 400, color = 0xcccccc) {
            const planeGeometry = new THREE.PlaneGeometry(width, height, 1, 1);
            const planeMaterial = new THREE.MeshPhongMaterial({ color });
            const plane = new THREE.Mesh(planeGeometry, mat);
            return plane;
        }

        function createFloor(mat, p_x, p_y, p_z) {
            // floor
            const plane = createPlane(mat)
            plane.rotation.x = -0.5 * Math.PI;
            plane.position.x = p_x;
            plane.position.y = p_y;
            plane.position.z = p_z;
            return plane
        }

        function createWall(mat, r_y, p_x, p_y, p_z) {
            const plane = createPlane(mat)
            plane.rotation.y = r_y * Math.PI;
            plane.position.x = p_x;
            plane.position.y = p_y;
            plane.position.z = p_z;
            return plane
        }
    </script>
</head>

<body>
    <canvas id="myCanvas"></canvas>
</body>

</html>